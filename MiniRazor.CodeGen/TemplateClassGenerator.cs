using System.Text;
using System;
using System.IO;
using System.Text.RegularExpressions;
using Microsoft.AspNetCore.Razor.Language;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using MiniRazor.CodeGen.Internal.Extensions;

namespace MiniRazor.CodeGen
{
    [Generator]
    public partial class TemplateClassGenerator : ISourceGenerator
    {
        private void ProcessFile(GeneratorExecutionContext context, string filePath, string content)
        {
            // Generate class name from file name
            var className = SanitizeIdentifier(Path.GetFileNameWithoutExtension(filePath));

            var code = Razor.ToCSharp(content, options =>
            {
                options.ConfigureClass((doc, node) =>
                {
                    node.ClassName = className;
                });
            });

            // Get model type from the template's base class
            var modelTypeName =
                Regex.Match(code, @"MiniRazor\.TemplateBase<(.*?)>").Groups[1].Value.NullIfWhiteSpace() ??
                "dynamic"; // fallback to dynamic (shouldn't normally happen)

            // Extend the template with some additional code
            var extensionCode = $@"
#nullable disable
/// <summary>Renders the template using the specified writer.</summary>
/// <remarks>This method was generated by MiniRazor.</remarks>
public static async global::System.Threading.Tasks.Task RenderAsync(global::System.IO.TextWriter output, {modelTypeName} model = default)
{{
    var template = new {className}();
    template.Output = output;
    template.Model = model;

    await template.ExecuteAsync().ConfigureAwait(false);
}}

/// <summary>Renders the template to a string.</summary>
/// <remarks>This method was generated by MiniRazor.</remarks>
public static async global::System.Threading.Tasks.Task<string> RenderAsync({modelTypeName} model = default)
{{
    using (var output = new global::System.IO.StringWriter())
    {{
        await RenderAsync(output, model).ConfigureAwait(false);
        return output.ToString();
    }}
}}
#nullable restore
".Trim();

            // Insert the extension code somewhere into the generated class
            code = code.Insert(
                code.IndexOf("public async override", StringComparison.Ordinal),
                extensionCode + "\n"
            );

            context.AddSource(className, SourceText.From(code, Encoding.UTF8));
        }

        /// <inheritdoc />
        public void Execute(GeneratorExecutionContext context)
        {
            foreach (var file in context.AdditionalFiles)
            {
                var isRazorTemplate = string
                    .Compare(".cshtml", Path.GetExtension(file.Path), StringComparison.OrdinalIgnoreCase) == 0;
            
                if (!isRazorTemplate)
                    continue;
            
                var content = file.GetText(context.CancellationToken)?.ToString();
            
                if (string.IsNullOrWhiteSpace(content))
                    continue;
            
                ProcessFile(context, file.Path, content!);
            }
        }

        /// <inheritdoc />
        public void Initialize(GeneratorInitializationContext context) { }
    }

    public partial class TemplateClassGenerator
    {
        private static string SanitizeIdentifier(string symbolName)
        {
            var buffer = new StringBuilder(symbolName);

            // Must start with a letter or an underscore
            if (buffer.Length > 0 && buffer[0] != '_' && !char.IsLetter(buffer[0]))
            {
                buffer.Insert(0, '_');
            }

            // Replace all other prohibited characters with underscores
            for (var i = 0; i < buffer.Length; i++)
            {
                if (buffer[i] != '_' && !char.IsLetterOrDigit(buffer[i]))
                    buffer[i] = '_';
            }

            return buffer.ToString();
        }
    }
}